[
    {
        "label": "glob",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "glob",
        "description": "glob",
        "detail": "glob",
        "documentation": {}
    },
    {
        "label": "json",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "json",
        "description": "json",
        "detail": "json",
        "documentation": {}
    },
    {
        "label": "os",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "os",
        "description": "os",
        "detail": "os",
        "documentation": {}
    },
    {
        "label": "pathlib",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pathlib",
        "description": "pathlib",
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "AsyncGenerator",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "quote_plus",
        "importPath": "urllib.parse",
        "description": "urllib.parse",
        "isExtraImport": true,
        "detail": "urllib.parse",
        "documentation": {}
    },
    {
        "label": "dotenv_values",
        "importPath": "dotenv",
        "description": "dotenv",
        "isExtraImport": true,
        "detail": "dotenv",
        "documentation": {}
    },
    {
        "label": "load_dotenv",
        "importPath": "dotenv",
        "description": "dotenv",
        "isExtraImport": true,
        "detail": "dotenv",
        "documentation": {}
    },
    {
        "label": "asyncio",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "asyncio",
        "description": "asyncio",
        "detail": "asyncio",
        "documentation": {}
    },
    {
        "label": "aiohttp",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "aiohttp",
        "description": "aiohttp",
        "detail": "aiohttp",
        "documentation": {}
    },
    {
        "label": "Pool",
        "importPath": "aiomultiprocess",
        "description": "aiomultiprocess",
        "isExtraImport": true,
        "detail": "aiomultiprocess",
        "documentation": {}
    },
    {
        "label": "numpy",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "numpy",
        "description": "numpy",
        "detail": "numpy",
        "documentation": {}
    },
    {
        "label": "fib",
        "importPath": "better_dotfiles.better_dotfiles",
        "description": "better_dotfiles.better_dotfiles",
        "isExtraImport": true,
        "detail": "better_dotfiles.better_dotfiles",
        "documentation": {}
    },
    {
        "label": "re",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "re",
        "description": "re",
        "detail": "re",
        "documentation": {}
    },
    {
        "label": "find_packages",
        "importPath": "setuptools",
        "description": "setuptools",
        "isExtraImport": true,
        "detail": "setuptools",
        "documentation": {}
    },
    {
        "label": "setup",
        "importPath": "setuptools",
        "description": "setuptools",
        "isExtraImport": true,
        "detail": "setuptools",
        "documentation": {}
    },
    {
        "label": "PROJECT",
        "kind": 5,
        "importPath": "docs.source.conf",
        "description": "docs.source.conf",
        "peekOfCode": "PROJECT = \"dydx\"\nCOPYRIGHT = \"2022, John Patrick Roach\"\nAUTHOR = \"John Patrick Roach\"\nDOCSTRING = \"Create dydx Bot Documentation\"\n# The short X.Y version\nVERSION = \"\"\n# The full version, including alpha/beta/rc tags\nRELEASE = \"\"\n# -- General configuration ---------------------------------------------------\n# If your documentation needs a minimal Sphinx version, state it here.",
        "detail": "docs.source.conf",
        "documentation": {}
    },
    {
        "label": "COPYRIGHT",
        "kind": 5,
        "importPath": "docs.source.conf",
        "description": "docs.source.conf",
        "peekOfCode": "COPYRIGHT = \"2022, John Patrick Roach\"\nAUTHOR = \"John Patrick Roach\"\nDOCSTRING = \"Create dydx Bot Documentation\"\n# The short X.Y version\nVERSION = \"\"\n# The full version, including alpha/beta/rc tags\nRELEASE = \"\"\n# -- General configuration ---------------------------------------------------\n# If your documentation needs a minimal Sphinx version, state it here.\n#",
        "detail": "docs.source.conf",
        "documentation": {}
    },
    {
        "label": "AUTHOR",
        "kind": 5,
        "importPath": "docs.source.conf",
        "description": "docs.source.conf",
        "peekOfCode": "AUTHOR = \"John Patrick Roach\"\nDOCSTRING = \"Create dydx Bot Documentation\"\n# The short X.Y version\nVERSION = \"\"\n# The full version, including alpha/beta/rc tags\nRELEASE = \"\"\n# -- General configuration ---------------------------------------------------\n# If your documentation needs a minimal Sphinx version, state it here.\n#\n# needs_sphinx = '1.0'",
        "detail": "docs.source.conf",
        "documentation": {}
    },
    {
        "label": "DOCSTRING",
        "kind": 5,
        "importPath": "docs.source.conf",
        "description": "docs.source.conf",
        "peekOfCode": "DOCSTRING = \"Create dydx Bot Documentation\"\n# The short X.Y version\nVERSION = \"\"\n# The full version, including alpha/beta/rc tags\nRELEASE = \"\"\n# -- General configuration ---------------------------------------------------\n# If your documentation needs a minimal Sphinx version, state it here.\n#\n# needs_sphinx = '1.0'\n# Add any Sphinx extension module names here, as strings. They can be",
        "detail": "docs.source.conf",
        "documentation": {}
    },
    {
        "label": "VERSION",
        "kind": 5,
        "importPath": "docs.source.conf",
        "description": "docs.source.conf",
        "peekOfCode": "VERSION = \"\"\n# The full version, including alpha/beta/rc tags\nRELEASE = \"\"\n# -- General configuration ---------------------------------------------------\n# If your documentation needs a minimal Sphinx version, state it here.\n#\n# needs_sphinx = '1.0'\n# Add any Sphinx extension module names here, as strings. They can be\n# extensions coming with Sphinx (named 'sphinx.ext.*') or your custom\n# ones.",
        "detail": "docs.source.conf",
        "documentation": {}
    },
    {
        "label": "RELEASE",
        "kind": 5,
        "importPath": "docs.source.conf",
        "description": "docs.source.conf",
        "peekOfCode": "RELEASE = \"\"\n# -- General configuration ---------------------------------------------------\n# If your documentation needs a minimal Sphinx version, state it here.\n#\n# needs_sphinx = '1.0'\n# Add any Sphinx extension module names here, as strings. They can be\n# extensions coming with Sphinx (named 'sphinx.ext.*') or your custom\n# ones.\nextensions: list = []\n# Add any paths that contain templates here, relative to this directory.",
        "detail": "docs.source.conf",
        "documentation": {}
    },
    {
        "label": "templates_path",
        "kind": 5,
        "importPath": "docs.source.conf",
        "description": "docs.source.conf",
        "peekOfCode": "templates_path = [\"_templates\"]\n# The suffix(es) of source filenames.\n# You can specify multiple suffix as a list of string:\n#\n# source_suffix = ['.rst', '.md']\nSOURCE_SUFFIX = \".rst\"\n# The master toctree document.\nMASTER_DOC = \"index\"\n# The language for content autogenerated by Sphinx. Refer to documentation\n# for a list of supported languages.",
        "detail": "docs.source.conf",
        "documentation": {}
    },
    {
        "label": "SOURCE_SUFFIX",
        "kind": 5,
        "importPath": "docs.source.conf",
        "description": "docs.source.conf",
        "peekOfCode": "SOURCE_SUFFIX = \".rst\"\n# The master toctree document.\nMASTER_DOC = \"index\"\n# The language for content autogenerated by Sphinx. Refer to documentation\n# for a list of supported languages.\n#\n# This is also used if you do content translation via gettext catalogs.\n# Usually you set \"language\" from the command line for these cases.\nlanguage: None = None\n# List of patterns, relative to source directory, that match files and",
        "detail": "docs.source.conf",
        "documentation": {}
    },
    {
        "label": "MASTER_DOC",
        "kind": 5,
        "importPath": "docs.source.conf",
        "description": "docs.source.conf",
        "peekOfCode": "MASTER_DOC = \"index\"\n# The language for content autogenerated by Sphinx. Refer to documentation\n# for a list of supported languages.\n#\n# This is also used if you do content translation via gettext catalogs.\n# Usually you set \"language\" from the command line for these cases.\nlanguage: None = None\n# List of patterns, relative to source directory, that match files and\n# directories to ignore when looking for source files.\n# This pattern also affects html_static_path and html_extra_path.",
        "detail": "docs.source.conf",
        "documentation": {}
    },
    {
        "label": "HTML_THEME",
        "kind": 5,
        "importPath": "docs.source.conf",
        "description": "docs.source.conf",
        "peekOfCode": "HTML_THEME = \"alabaster\"\n# Theme options are theme-specific and customize the look and feel of a theme\n# further.  For a list of options available for each theme, see the\n# documentation.\n#\nHTML_THEME_OPTIONS = {\n    \"sidebar_width\": \"260px\",\n    \"github_user\": \"johnpatrickroach\",\n    \"github_repo\": \"better-crypto\",\n}",
        "detail": "docs.source.conf",
        "documentation": {}
    },
    {
        "label": "HTML_THEME_OPTIONS",
        "kind": 5,
        "importPath": "docs.source.conf",
        "description": "docs.source.conf",
        "peekOfCode": "HTML_THEME_OPTIONS = {\n    \"sidebar_width\": \"260px\",\n    \"github_user\": \"johnpatrickroach\",\n    \"github_repo\": \"better-crypto\",\n}\n# Add any paths that contain custom static files (such as style sheets) here,\n# relative to this directory. They are copied after the builtin static files,\n# so a file named \"default.css\" will overwrite the builtin \"default.css\".\nHTML_STATIC_PATH = [\"_static\"]\n# Custom sidebar templates, must be a dictionary that maps document names",
        "detail": "docs.source.conf",
        "documentation": {}
    },
    {
        "label": "HTML_STATIC_PATH",
        "kind": 5,
        "importPath": "docs.source.conf",
        "description": "docs.source.conf",
        "peekOfCode": "HTML_STATIC_PATH = [\"_static\"]\n# Custom sidebar templates, must be a dictionary that maps document names\n# to template names.\n#\n# The default sidebars (for documents that don't match any pattern) are\n# defined by theme itself.  Builtin themes are using these templates by\n# default: ``['localtoc.html', 'relations.html', 'sourcelink.html',\n# 'searchbox.html']``.\n#\n# html_sidebars = {}",
        "detail": "docs.source.conf",
        "documentation": {}
    },
    {
        "label": "HTMLHELP_BASENAME",
        "kind": 5,
        "importPath": "docs.source.conf",
        "description": "docs.source.conf",
        "peekOfCode": "HTMLHELP_BASENAME = \"dydx\"\n# -- Options for LaTeX output ------------------------------------------------\nlatex_elements: dict = {\n    # The paper size ('letterpaper' or 'a4paper').\n    #\n    # 'papersize': 'letterpaper',\n    # The font size ('10pt', '11pt' or '12pt').\n    #\n    # 'pointsize': '10pt',\n    # Additional stuff for the LaTeX preamble.",
        "detail": "docs.source.conf",
        "documentation": {}
    },
    {
        "label": "man_pages",
        "kind": 5,
        "importPath": "docs.source.conf",
        "description": "docs.source.conf",
        "peekOfCode": "man_pages = [(MASTER_DOC, \"createaioapp\", DOCSTRING, [AUTHOR], 1)]\n# -- Options for Texinfo output ----------------------------------------------\n# Grouping the document tree into Texinfo files. List of tuples\n# (source start file, target name, title, author,\n#  dir menu entry, description, category)\ntexinfo_documents = [\n    (\n        MASTER_DOC,\n        \"Createaioapp\",\n        DOCSTRING,",
        "detail": "docs.source.conf",
        "documentation": {}
    },
    {
        "label": "texinfo_documents",
        "kind": 5,
        "importPath": "docs.source.conf",
        "description": "docs.source.conf",
        "peekOfCode": "texinfo_documents = [\n    (\n        MASTER_DOC,\n        \"Createaioapp\",\n        DOCSTRING,\n        AUTHOR,\n        \"Createaioapp\",\n        \"One line description of project.\",\n        \"Miscellaneous\",\n    )",
        "detail": "docs.source.conf",
        "documentation": {}
    },
    {
        "label": "EPUB_TITLE",
        "kind": 5,
        "importPath": "docs.source.conf",
        "description": "docs.source.conf",
        "peekOfCode": "EPUB_TITLE = PROJECT\n# The unique identifier of the text. This can be a ISBN number\n# or the project homepage.\n#\n# epub_identifier = ''\n# A unique identification for the text.\n#\n# epub_uid = ''\n# A list of files that should not be packed into the epub file.\nepub_exclude_files = [\"search.html\"]",
        "detail": "docs.source.conf",
        "documentation": {}
    },
    {
        "label": "epub_exclude_files",
        "kind": 5,
        "importPath": "docs.source.conf",
        "description": "docs.source.conf",
        "peekOfCode": "epub_exclude_files = [\"search.html\"]",
        "detail": "docs.source.conf",
        "documentation": {}
    },
    {
        "label": "fib",
        "kind": 2,
        "importPath": "src.better_dotfiles.better_dotfiles",
        "description": "src.better_dotfiles.better_dotfiles",
        "peekOfCode": "def fib(num: int) -> int:\n    \"\"\"Fibonacci test.\"\"\"\n    return num if num < 2 else fib(num - 1) + fib(num - 2)",
        "detail": "src.better_dotfiles.better_dotfiles",
        "documentation": {}
    },
    {
        "label": "Category",
        "kind": 6,
        "importPath": "src.better_dotfiles.trending_homebrew",
        "description": "src.better_dotfiles.trending_homebrew",
        "peekOfCode": "class Category:\n    \"\"\"Category class.\"\"\"\n    data_day_ranges: list[str] = DATA_DAY_RANGES\n    def __init__(self, name: str, category_data_url: str, k: int = 10) -> None:\n        \"\"\"Construct the instance.\"\"\"\n        self.name: str = name\n        self.data_coverage: int = 0\n        self.category_data_url: str = category_data_url\n        self.data: dict = {}\n        self.total_counts: dict = {}",
        "detail": "src.better_dotfiles.trending_homebrew",
        "documentation": {}
    },
    {
        "label": "Item",
        "kind": 6,
        "importPath": "src.better_dotfiles.trending_homebrew",
        "description": "src.better_dotfiles.trending_homebrew",
        "peekOfCode": "class Item:\n    \"\"\"Item class.\"\"\"\n    data_day_ranges: list[str] = DATA_DAY_RANGES\n    def __init__(self, name: str, trend: int = 0) -> None:\n        \"\"\"Construct the Item instance.\"\"\"\n        self.name: str = name\n        self.data_coverage: int = 0\n        self.counts: dict = {}\n        self.percents: dict = {}\n        self.trend: int = trend",
        "detail": "src.better_dotfiles.trending_homebrew",
        "documentation": {}
    },
    {
        "label": "fib_test",
        "kind": 2,
        "importPath": "tests.better_dotfiles_test",
        "description": "tests.better_dotfiles_test",
        "peekOfCode": "def fib_test() -> None:\n    assert fib(0) == 0\n    assert fib(1) == 1\n    assert fib(2) == 1\n    assert fib(3) == 2\n    assert fib(4) == 3\n    assert fib(5) == 5\n    assert fib(10) == 55",
        "detail": "tests.better_dotfiles_test",
        "documentation": {}
    },
    {
        "label": "read_version",
        "kind": 2,
        "importPath": "setup",
        "description": "setup",
        "peekOfCode": "def read_version():\n    \"\"\"read_version.\"\"\"\n    init_py = os.path.join(\n        os.path.dirname(__file__), \"src\", \"better_dotfiles\", \"__init__.py\"\n    )\n    with open(init_py, encoding=\"utf-8\") as open_file:\n        for line in open_file:\n            match = REGEXP.match(line)\n            if match is not None:\n                return match.group(1)",
        "detail": "setup",
        "documentation": {}
    },
    {
        "label": "read_requirements",
        "kind": 2,
        "importPath": "setup",
        "description": "setup",
        "peekOfCode": "def read_requirements(path: str) -> List[str]:\n    \"\"\"read_requirements.\"\"\"\n    file_path = PARENT / path\n    with open(file_path, encoding=\"utf-8\") as open_file:\n        return open_file.read().split(\"\\n\")\nif __name__ == \"__main__\":\n    setup(\n        name=\"better_dotfiles\",\n        version=read_version(),\n        description=\"Better dotfiles management tools.\",",
        "detail": "setup",
        "documentation": {}
    },
    {
        "label": "REGEXP",
        "kind": 5,
        "importPath": "setup",
        "description": "setup",
        "peekOfCode": "REGEXP = re.compile(r'^__version__\\W*=\\W*\"([\\d.abrc]+)\"')\nPARENT = pathlib.Path(__file__).parent\ndef read_version():\n    \"\"\"read_version.\"\"\"\n    init_py = os.path.join(\n        os.path.dirname(__file__), \"src\", \"better_dotfiles\", \"__init__.py\"\n    )\n    with open(init_py, encoding=\"utf-8\") as open_file:\n        for line in open_file:\n            match = REGEXP.match(line)",
        "detail": "setup",
        "documentation": {}
    },
    {
        "label": "PARENT",
        "kind": 5,
        "importPath": "setup",
        "description": "setup",
        "peekOfCode": "PARENT = pathlib.Path(__file__).parent\ndef read_version():\n    \"\"\"read_version.\"\"\"\n    init_py = os.path.join(\n        os.path.dirname(__file__), \"src\", \"better_dotfiles\", \"__init__.py\"\n    )\n    with open(init_py, encoding=\"utf-8\") as open_file:\n        for line in open_file:\n            match = REGEXP.match(line)\n            if match is not None:",
        "detail": "setup",
        "documentation": {}
    }
]